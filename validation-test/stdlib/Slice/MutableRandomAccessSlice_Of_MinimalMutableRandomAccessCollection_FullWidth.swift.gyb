// -*- swift -*-

//===----------------------------------------------------------------------===//
// Automatically Generated From validation-test/stdlib/Slice/Inputs/Template.swift.gyb
// Do Not Edit Directly!
//===----------------------------------------------------------------------===//

// RUN: rm -rf %t
// RUN: mkdir -p %t
// RUN: %S/../../../utils/gyb %s -o %t/main.swift
// RUN: %S/../../../utils/line-directive %t/main.swift -- %target-build-swift %t/main.swift -o %t/MutableRandomAccessSlice_Of_MinimalMutableRandomAccessCollection_FullWidth.swift.gyb.a.out
// RUN: %S/../../../utils/line-directive %t/main.swift -- %target-run %t/MutableRandomAccessSlice_Of_MinimalMutableRandomAccessCollection_FullWidth.swift.gyb.a.out
// REQUIRES: executable_test

// FIXME: the test is too slow when the standard library is not optimized.
// REQUIRES: optimized_stdlib

import StdlibUnittest
import StdlibCollectionUnittest

// Also import modules which are used by StdlibUnittest internally. This
// workaround is needed to link all required libraries in case we compile
// StdlibUnittest with -sil-serialize-all.
import SwiftPrivate
#if _runtime(_ObjC)
import ObjectiveC
#endif

var SliceTests = TestSuite("Collection")

let prefix: [Int] = []
let suffix: [Int] = []

func makeCollection(elements: [OpaqueValue<Int>])
  -> MutableRandomAccessSlice<MinimalMutableRandomAccessCollection<OpaqueValue<Int>>> {
  var baseElements = prefix.map(OpaqueValue.init)
  baseElements.append(contentsOf: elements)
  baseElements.append(contentsOf: suffix.map(OpaqueValue.init))
  let base = MinimalMutableRandomAccessCollection(elements: baseElements)
  let startIndex = base.index(
    numericCast(prefix.count),
    stepsFrom: base.startIndex)
  let endIndex = base.index(
    numericCast(prefix.count + elements.count),
    stepsFrom: base.startIndex)
  return MutableRandomAccessSlice(
    base: base,
    bounds: startIndex..<endIndex)
}

func makeCollectionOfEquatable(elements: [MinimalEquatableValue])
  -> MutableRandomAccessSlice<MinimalMutableRandomAccessCollection<MinimalEquatableValue>> {
  var baseElements = prefix.map(MinimalEquatableValue.init)
  baseElements.append(contentsOf: elements)
  baseElements.append(contentsOf: suffix.map(MinimalEquatableValue.init))
  let base = MinimalMutableRandomAccessCollection(elements: baseElements)
  let startIndex = base.index(
    numericCast(prefix.count),
    stepsFrom: base.startIndex)
  let endIndex = base.index(
    numericCast(prefix.count + elements.count),
    stepsFrom: base.startIndex)
  return MutableRandomAccessSlice(
    base: base,
    bounds: startIndex..<endIndex)
}

func makeCollectionOfComparable(elements: [MinimalComparableValue])
  -> MutableRandomAccessSlice<MinimalMutableRandomAccessCollection<MinimalComparableValue>> {
  var baseElements = prefix.map(MinimalComparableValue.init)
  baseElements.append(contentsOf: elements)
  baseElements.append(contentsOf: suffix.map(MinimalComparableValue.init))
  let base = MinimalMutableRandomAccessCollection(elements: baseElements)
  let startIndex = base.index(
    numericCast(prefix.count),
    stepsFrom: base.startIndex)
  let endIndex = base.index(
    numericCast(prefix.count + elements.count),
    stepsFrom: base.startIndex)
  return MutableRandomAccessSlice(
    base: base,
    bounds: startIndex..<endIndex)
}

var checksAdded: Box<Set<String>> = Box([])
var resiliencyChecks = CollectionMisuseResiliencyChecks.all
resiliencyChecks.creatingOutOfBoundsIndicesBehavior = .expectationFailure
resiliencyChecks.subscriptOnOutOfBoundsIndicesBehavior = .trap
resiliencyChecks.subscriptRangeOnOutOfBoundsRangesBehavior = .trap

// ###sourceLocation(file: "/Users/gribozavr/src.public.swift-collections/swift/validation-test/stdlib/Slice/Inputs/Template.swift.gyb", line: 162)
SliceTests.addMutableRandomAccessCollectionTests(
  "MutableRandomAccessSlice_Of_MinimalMutableRandomAccessCollection_FullWidth.swift.gyb.",
  makeCollection: makeCollection,
  wrapValue: identity,
  extractValue: identity,
  makeCollectionOfEquatable: makeCollectionOfEquatable,
  wrapValueIntoEquatable: identityEq,
  extractValueFromEquatable: identityEq,
// ###sourceLocation(file: "/Users/gribozavr/src.public.swift-collections/swift/validation-test/stdlib/Slice/Inputs/Template.swift.gyb", line: 171)
  makeCollectionOfComparable: makeCollectionOfComparable,
  wrapValueIntoComparable: identityComp,
  extractValueFromComparable: identityComp,
// ###sourceLocation(file: "/Users/gribozavr/src.public.swift-collections/swift/validation-test/stdlib/Slice/Inputs/Template.swift.gyb", line: 175)
  checksAdded: checksAdded,
  resiliencyChecks: resiliencyChecks,
  outOfBoundsIndexOffset: 6
// ###sourceLocation(file: "/Users/gribozavr/src.public.swift-collections/swift/validation-test/stdlib/Slice/Inputs/Template.swift.gyb", line: 179)
  , withUnsafeMutableBufferPointerIsSupported: false,
  isFixedLengthCollection: true
// ###sourceLocation(file: "/Users/gribozavr/src.public.swift-collections/swift/validation-test/stdlib/Slice/Inputs/Template.swift.gyb", line: 182)
)
// ###sourceLocation(file: "/Users/gribozavr/src.public.swift-collections/swift/validation-test/stdlib/Slice/Inputs/Template.swift.gyb", line: 184)

runAllTests()
